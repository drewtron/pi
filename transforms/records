BEGIN {
  RS="\r\t"; FS="\t";
}

#This is a freebcp message to be skipped
match($0, /\nStarting copy/) {
  next
}

#batch separators every N records, just a comment marker
#this is used as a split point piping along to parallel
NR%1000==0 {
  print "//BATCH";
}

function escape() {
  gsub(/\\/, "\\\\");
  gsub(/'/, "\\u02BC");
  gsub(/\r/, "");
  gsub(/\n/, "\\n");
  gsub(/\0/, "");
  gsub(/[^\x00-\x7F]/, "");
}

function strip(s) {
  sub(/^[ ]+/, "", s)
  sub(/[ ]+$/, "", s)
  return s
}

function pop(arr) {
  delete arr[length(arr)]
}

function defaultValue(original, value) {
  if (length(original)) {
    return original;
  } else {
    return value;
  }
}

function arraycopy(arr1,arr2) {
  for(i in arr1) {
    arr2[i] = arr1[i]
    n++
  }
  return n
}

function taxonomyPath(segments) {
  results = ""
  for (i = 1; i <= length(segments); i++) {
    results = results "_" strip(segments[i]) "_"
  }
  return sprintf("%s%s", length(segments) - 1, results)
}

function employmentDate(yy, mm) {
  if (length(yy)) {
    if (!length(mm)) {
      mm =  "1"
    }
    return sprintf("%d-%02d-01", yy, mm)
  } else {
    return ""
  }
}

function facetize(person, facetPath, storeInField) {
  #if you send an array, use it
  if (isarray(facetPath)) {
    arraycopy(facetPath, taxonomyFacets);
  } else {
    split(facetPath, taxonomyFacets, ">")
  }

  while (length(taxonomyFacets) > 0) {
    print "db.people.update("
    printf "{ personid: '%s'},\n", person
    printf "{ $addToSet: {%s: '%s'} },\n", storeInField, taxonomyPath(taxonomyFacets)
    printf "{ upsert: true }\n"
    print "\n);\n"
    pop(taxonomyFacets);
  }
}
